---
title: "JVM知识"
date: 2022-08-21T17:25:09+08:00
draft: false
categories: [JVM]
---
## JVM的内存模型

* 内存模型我大概记得有程序计数器，虚拟机栈，还有方法区，栈和堆，
然后栈是私有的，堆的话是多线程共享的，
他又分为年轻代和老年代，年轻代的话有伊甸dian园区，survivor0(色如why零)区，survivor1区，
一般的话我们通常给他设置成一个8:1:1的比例。

## JVM加载class文件的原理机制

* JVM去加载我们class的原理机制的话，就是我们java中的一个所有类，都需要类加载器，装载到我们的JVM中才可以运行，
就是把我们文件从我们的硬盘啊，读取到我们的内存中，
所以我们在写程序的时候，其实我们几乎是不用关心这个类的加载，
因为这些都是隐式装载的，除非我们有些一些特殊的用法，想是我们的反射啊，就需要我们显示加载的所以需要的一个类，
那我们JVM中它的一个类的装载啊，是由我们类的加载器，就是我们的ClassLoader啊，我们ClassLoader和他的一个子类，去实现的，
是我们JVM中的一个类加载器，他是一个重要的java运行的一个系统组件啊，他就负责在我们运行是去查找和装入
，我们的一个类文件中的一个类，由于我们Java中的一个跨平台性，所以经过一个编译的一个Java，它的一个原程序呢，并不是一个可知性的程序啊，
而是一个或者多个的一个类文件，所以在我们java程序中，
如果我们需要使用某个类的时候，JVM他会确保我们这个类啊，它的一个被加载了，
然后呢，我们的连接验证准备跟解析啊，然后最后到我们的初始化，
所以类的加载，是把我们类的class文件啊，中的一个数据呢，持续的把它读入到我们的内存中，
通常就是我们要创建一个节点嘛，数组嘛，然后去就是他的一个底层是创建一个节点数组，然后把他读入到我们的class文件中，
然后产生跟我们这个所加载的类相对应的一个class对象，差不多这样。


## java回收机制讲讲？

* 使用Java的时候，会创建很多对象，但我们没手动将这些对象进行清除，如果用C/C++语言的时候，用完是需要自己释放掉， 
* Java不用我们自己手动释放"垃圾"是因为JVM帮我们做了自动回收垃圾， 
* 我个人对垃圾的定义：只要对象不再被使用了，那我们就认为该对象就是垃圾，对象所占用的空间就可以被回收。 
* 判断对象不再被使用用的是 引用计数法 和 可达性分析法。 
* 引用计数法:当对象被引用则+1，但对象引用失败则-1。当计数器为0时，说明对象不再被引用，可以被可回收,缺点是如果循环依赖，比如A依赖B,B依赖A,就无法判断是否被回收。 
* 可达性分析法:从「GC Roots」开始向下搜索，当对象到「GC Roots」都没有任何引用相连时，说明对象是不可用的，可以被回收。 
* JVM用的就是「可达性分析算法」来判断对象是否垃圾。 
* 垃圾回收的第一步就是「标记」，标记哪些没有被「GC Roots」引用的对象，标记完之后，我们就可以选择直接「清除」，只要不被「GC Roots」关联的，都可以干掉。

